# 제 9장 HTTP에 기능을 추가한 프로토콜

## 9.1 HTTP를 기본으로 하는 프로토콜

</br>

> HTTP의 규격이 만들어졌을 무렵엔 주로 HTML로 작성된 문서를  
> 전송하기 위한 프로토콜로 HTTP를 생각해왔다.
>
> 그러나 HTTP의 제한이나 한계로 인해 기능을 작성할 수 있다고 하더라도  
> 결코 효율적이라고 할 수는 없다.
>
> 기존의 웹사이트들이 HTTP로 만들어졌기 때문에  
> 하위 호환을 보장해야함으로 아예 다른 프로토콜을 사용하는 것이 아니라  
> HTTP를 기반으로 추가하는 형태로 프로토콜이 추가 되어왔다.

</br>

## 9.2 HTTP의 병목 현상을 해소하는 SPDY

</br>

> 구글이 2010년에 발표한 SPDY는 HTTP는 병목 현상을 해소하고  
> 웹 페이지 로딩 시간을 50% 단축한다는 목표를 세우고 개발되었다.

</br>

### 9.2.1 HTTP의 병목 현상

</br>

> 동시접속자가 수백만 명, 수천만명이라고 가정했을 때  
> 단시간에 대량의 정보가 발생한다.
>
> 이렇게 갱신된 정보를 가능한 빨리 실시간으로 표시하기 위해서는  
> 서버상의 정보고 갱신 되었을 때, 그것을 클라이언트의 화면에 반영해야한다.
>
> HTTP에서는 서버의 정보가 갱신되었는지 아닌지를 알기 위해서  
> 클라이언트가 항상 서버측에 확인하러 가야한다.  
> 만약 서버상의 정보가 갱신되지 않은 경우 불필요한 통신이 발생하게 된다.

</br>

- 병목 사항이 발생하는 이유
  - 1개의 커넥션으로 1개의 리퀘스트만 보낼 수 있다.
  - 리퀘스트는 클라이언트에서만 시작할 수 있다. 리스폰스만 받는 것은 불가능하다.
  - 리퀘스트/리스폰스 헤더를 압축하지 않은 체로 보낸다.
  - 중복된 헤더를 보낸다.
  - 데이터 압축을 임의로 선택할 수 있다. 압축해서 보내는 것이 강제적이지 않다.

</br>

- Ajax에 의한 해결방법

> Ajax는 DOM 조작을 활용하는 방식으로  
> 웹 페이지의 일부분만 고쳐 쓸 수 있는 비동기 통신 방법이다.  
> 기존의 동기식 통신 방법과 달리 페이지의 일부분만 갱신되기 때문에  
> 리스폰스로 전송되는 데이터 양은 줄어든다는 장점이 있다.
>
> Ajax의 핵심기술은 XMLHttpRequest라는 API로  
> JavaScript 등의 스크립트 언어로 서버와 HTTP 통신을 할 수 있다.
>
> Ajax를 사용해서 실시간으로 서버에서 정보를 취득하려고 하면  
> 대량의 리퀘스트가 발생한다는 문제가 있다.  
> 또 HTTP 자신이 가지고 있는 문제가 해결 되는 것은 아니다.

</br>

- Comet에 의한 해결 방법

> Comet은 서버 측의 콘텐츠에 갱신이 있었을 경우,  
> 클라이언트로부터 리퀘스트를 기다리지 않고 클라이언트에 보내기 위한 방법이다.  
> 응답을 연장시큼으로써 서버에서 통신을 개시하는 서버 푸시기능을 유사하게 따른다.
>
> 통상 리퀘스트가 오면 리스폰스를 바로 반호나하짐나 Comet에서는 리스폰스를  
> 보류 상태로 해 두고, 서버의 콘텐츠가 갱신 되었을 때 리스폰스를 반환한다는 것이다.  
> 이것에 의해서 서버에서 갱신된 컨텐츠가 있다면 바로 클라이언트에 반영할 수 있다.
>
> 콘텐츠를 실시간으로 갱신할 수는 있지만 리스폰스를 보류하기 위해서  
> 커넥션을 유지한느 시간이 길어진다.  
> 커넥션을 유지하는 동안은 리소스를 소비한다. 또한 HTTP 자체의 문제가 해결 되는 것도 아니다.

</br>

- SPDY의 목표

</br>

> Ajax와 Comet 등 사용성을 쾌적하게 하는 여러가지 기술이 등장해서 어느정도 개선되었지만,  
> HTTP라는 프로토콜의 제약은 없앨 수 없다.  
> 근본적인 개선을 위해서는 프로토콜 레벨에서의 개선이 필요하다.

</br>

### 9.2.2 SPDY 설계와 기능

</br>

> SPDY는 HTTP를 완전히 바꿔 놓는 것이 아니라  
> TCP/IP의 애플리케이션 계층과 트랜스포트 계층 사이에 새로운 세션 계층을 추가하는 형태로 동작한다.  
> 또한, SPDY는 보안을 위해 표준으로 SSL을 사용하도록 되어있다.  
> SPDY가 세션계층으로 들어감으로써 데이터의 흐름을 제어하지만  
> HTTP의 커넥션은 확립되어 있다.  
> 따라서 HTTP 메소드나 쿠키, HTTP 메시지 등을 그대로 사용할 수 있다.

</br>

- 다중화 스트림
  - 단일 TCP 접속을 통해 복수의 HTTP 리퀘스트를 무제한으로 처리할 수 있다.
  - 한 번의 TCP 접속으로 리퀘스트를 주고 받는 것이 가능하기 때문에 TCP 효율이 높아진다.
- 리퀘스트의 우선 순위 부여
  - SPDY는 무제한으로 리퀘스트를 병렬 처리할 수 있지만, 각 리퀘스트에 우선순위를 할당할 수 있다.
  - 이것은 복수의 리퀘스트를 보낼 때 대역폭이 좁으면 처리가 늦어지는 현상을 해결하기 위함이다
- HTTP 헤더 압축
  - 헤더를 압축하여 더 적은 패킷과 송신 바이트로 통신 할 수 있다.
- 서버 푸시 기능
  - 서버에서 클라이언트로 데이터를 푸쉬하는 서버 푸시 기능을 지원한다.
  - 그래서 서버측은 클라이언트 측에서 리퀘스트를 기다리지 않고 데이터를 보낼 수 있다
- 서버 힌트 기능
  - 서버가 클라이언트에게 리퀘스트 해야 할 리소스를 제안할 수 있다.
  - 클라이언트가 자원을 발견하기 전에 리소스의 존재를 알 수 있기 때문에 이미 캐시를 가지고 있는 상태라면 불필요한 리퀘스트를 보내지 않아도 된다.

</br>

## 9.3 브라우저에서 양방향 통신을 하는 WebSocket

</br>

> Ajax와 Comet을 사용한 통신은 웹 브라우징을 고속화 하지만  
> HTTP라는 프로토콜을 사용하고 있는 이상, 병목 현상ㅇ르 해결할 수 없다.  
> WebSocket은 새로운 프로토콜과 API에 의해  
> 이 문제를 해결하기 위한 기술로서 개발되어 있다.
> </br>

### 9.3.1 WebSocket의 설계와 기능

</br>

> WebSocket은 웹 브라우저와 웹 서버를 위한 양방향 통신 규격으로  
> WebSocket 프로토콜을 IETF가 책정하고 WebSocket API를 W3C가 책정하고 있다.  
> 주로 Ajax나 Comet에서 사용하는 XMLHttpRequest의 결점을  
> 해결하기 위한 기술로서 개발이 진행 되고 있다.

</br>

### 9.3.2 WebSocket 프로토콜

</br>

> WebSocket은 웹 서버와 클라이언트가 한 번 접속을 확립하면  
> 그 뒤의 통신을 모두 전용 프로토콜로 하는 방식으로 JSON이나 XML, HTML이나 이미지 등  
> 임의 형식의 데이터를 보내게 된다.
>
> HTTP에 의한 접속의 출발점이 클라이언트에 있다는 것은 변합이 없지만  
> 한 번 접속을 확립하면 서버, 클라이언트 어느쪽에서도 송신 할 수 있다.

</br>

- 서버 푸시 기능
- 통신량의 삭감
  - 접속을 한 번 확립하면 접속을 유지하려고 한다.
  - HTTP에 비해서 자주 접속을 하는 오버헤드가 작아지고, 또 헤더의 사이즈도 작기때문이다.
- 핸드쉐이크/리퀘스트
  - Upgrade 헤더 필드를 사용하여 프로토콜을 변경하는 것으로 핸드 쉐이크를 실시
  - Set-WebSocket-Key에는 핸드쉐이크에 필요한 키가 저장
  - Set-WebSocket-Protocol에는 사용하는 서브 프로토콜이 저장되어 있따.
  - 서브 프로토콜은 WebSocket 프로토콜에 의한 커넥션을 여러 개로 구분하고 싶을 때 이름을 붙여서 정의
- 핸드쉐이크/리스폰스
  - 앞선 리퀘스트에 대한 리스폰스 상태코드는 101-Switching Protocols로 반환

## 9.4 등장이 기다려지는 HTTP/2.0

</br>

- HTTP/2.0에서 논의되는 7가지 기술

|           압축           |       SPDY 또는 Friendly        |
| :----------------------: | :-----------------------------: |
|          다중화          |              SPDY               |
|       TLS의 의무화       |        Speed + Mobility         |
|       네고시에이션       | Speed + Mobility, 또는 Friendly |
| 클라이언트 풀/ 서버 푸시 |        Speed + Mobility         |
|        흐름 제어         |              SPDY               |
|        WebSocket         |        Speed + Mobility         |

</br>

## 9.5 웹 서버 상의 파일을 관리하는 WebDAV(Web-based- Distributed Authoring and Versioning)

</br>

> Web DAV는 웹서버의 콘텐츠에 대해서, 직접 파일 복사나 편집 작업 등을 할 수 이쓴 분산 파일 시스템으로  
> HTTP/1.1을 확장한 프로토콜로 RFC 4918로 정의 되어 있다.
> 파일 작성이나 삭제 등 기본적인 긴으 이외에 파일 작성자 등의 관리나 편집 중에  
> 다른 유저가 다시 고쳐쓰지 못하도록 잠금 기능, 갱신 정보를 관리하는 리비전 기능 등이 준비되어 있다.

</br>

### 9.5.1 HTTP/1.1을 확장한 WebDAV

</br>

- 컬렉션
  - 여러 개의 리소스를 한꺼번에 관리하기 위한 개념이다.
  - 각종 조작은 컬렉션 단위로 할 수 있다.
- 자원
  - 파일이나 컬렉션을 리소스라고 부릅니다.
- 프로퍼티
  - 리소스의 프로퍼티를 정의한 것이다.
- 잠금
  - 파일을 편집할 수 없는 상태로 한다. 여러명의 사람이 동시에 작성하는 것을 예방

</br>

### 9.5.2 WebDAV에서 추가된 메서드와 상태 코드

</br>

- WebDAV에서는 리모트 파일 관리를 위해 HTTP/1.1에 다음의 메소드가 추가 되어 있다.

  - PROFIND: 프로퍼티 취득
  - PROPPATCH: 프로퍼티 변경
  - MKCOL: 컬렉션 작성
  - COPY: 리소스 및 프로퍼티 복제
  - MOVE: 리소스 이동
  - LOCK: 리소스 잠금
  - UNLOCK: 리소스 잠금 해제

- 메서드 확장에 맞춰서 상태코드도 확장
  - 102
  - 207
  - 422
  - 423
  - 424
  - 507

</br>
