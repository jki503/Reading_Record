# 제 2장 간단한 프로토콜 HTTP

## 2.1 HTTP는 클라이언트와 서버간에 통신을 한다.

> HTTP란 응용계층에 있는 프로토콜 중 하나로  
> 클라이언트 - 서버 구조에서 리소스 주고 받을 수 있도록 해주는 프로토콜이다.

</br>

## 2.1 HTTP는 리퀘스트와 리스폰스를 교환하여 성립

</br>

- Request

```http
POST /form/entry HTTP/1.1
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 16

name=ueno&age=37
```

- Response

```http
HTTP 1.1/ 200 OK
Date: Tue, 10 Jul 2012 06:50:15 GMT
Content-Length: 262
Content-Type: text/html
```

> post 예시로 이렇게 구성되어 있다.

</br>

### 실제 개발에서 내 경험

- POST에 대한 응답코드로 201을 사용했고 REST 룰을 지키려면 Location 헤더를 입력해주어야한다.
  - 사실 Location 헤더를 주지 않아도 프론트에서 라우터를 가지고 있어 사용하지 않는다고 함.
- GET에는 바디를 실으면 안된다.
  - Axios.get은 아예 body를 실지도 못하게 되어있고 원래 룰이 get에 대해서는 바디에 실으면 안된다.
- POST를 SSR에서 사용할 때 PRG 패턴을 사용해야한다.
  - POST는 멱등성이 보장되지 않는다.

</br>

## 2.3 HTTP는 상태를 유지하지 않는 프로토콜 -> Stateless

</br>

- 서버가 클라이언트의 상태를 보존하지 않는다.
- 서버는 이에 따라 클라이언트의 이전 요청과 무관하게 응답할 수 있다.
  - 장점
    - 서버의 확정성이 높다.
  - 단점
    - 클라이언트가 전송할 데이터가 추가된다.
    - 로그인과 같은 경우 쿠키나 세션 및 JWT를 사용해야 한다.

</br>

### Stateless 예시

> 기존 클라이언트가 특정 서버에 종속하여 소통해야만 한다.

- 클라이언트: 일식집에서 스시에 대한 정보를 요청
- 서버 1: 스시 A는 15,000원이다.
- 클라이언트: 2개 주문하겠다.
- 서버 2: 무엇을 2개 주문한다는 거지?
- 클라이언트: 계좌이체로 결제하겠다.
- 서버 3: 무엇을 몇 개를 계좌이체로 결제한다는 것이지..?

</br>

> 위처럼 stateful하게 요청을 보낼 경우 각 서버는 무엇을 요청하는지 정확히 알기 어렵다.
> 따라서 특정 서벙 종속되지 않도록 각 리소스 요청에 맞는 요청 정보를 보내줘야한다.

</br>

## 2.4 리퀘스트 URI로 리소스를 식별

</br>

> HTTP는 URI를 사용하여 인터넷 상의 리소스를 지정한다.  
> URI를 사용하기 때문에 인터넷 상의 어떤 장소에 있는 리소스도 호출 할 수 있다.

</br>

## 2.5 서버에 임무를 부여하는 HTTP 메소드

</br>

| 메서드  |                          액션                          |
| :-----: | :----------------------------------------------------: |
|  POST   |                      엔티티 생성                       |
|   GET   |                      데이터 요청                       |
|   PUT   |               데이터 변경 및 파일 업로드               |
| DELETE  |                      엔티티 삭제                       |
|  HEAD   |                    메시지 헤더 획득                    |
| OPTIONS | 등록된 URI로 지정한 리소스를 제공하고 있는 메소드 반환 |

> 위 개념이 HTTP API와 REST API의 개념이 혼용될 수 있음을 주의 해야한다.
> 일반적으로 CRUD는 POST, GET, PUT, DELETE로 많이 사용되며  
> 개발 편의에 따라 POST와 PUT을 같이 사용하는 경우가 있다.

</br>

### 새로 알게된 사실

- PUT을 사용하면 FTP와 같이 파일 전송 프로토콜같이 사용할 수도 있다.

### HTTP메소드와 멱등성

</br>

- 기본적으로 POST는 멱등성을 보장하지 않는다.
  - PRG 패턴을 사용하지 않거, POST이후 request uri를 갱신하지 않고 새로고침을 누르면 동일 entity를 또 생성할 수 있다..
- 하지만 개발자에 따라 멱등성을 보장하지 않도록 망칠 수 있다.
  - DELETE 요청이 가장 오래전에 생성한 엔티티를 삭제한다라고 가정할때 - 한 번 더 요청을 보내면 동일 엔티티 삭제가 아니라, 바로 이후에 생성된 엔티티가 삭제 된다. -

</br>

### 실제 개발에서 API를 분리하지 않았던 경험

- 커뮤니티 개발을 할 때 기존의 익명A 사용자가 익명B에게 메시지를 보내는 경우

  - 기존 채팅방이 있다면 메시지를 생성하기만 하면 되고
  - 없다면 채팅방을 만들고 메시지를 생성해야 했다.

- 해결 방법1
  - 메시지 POST API일때 없다면 메시지 생성 실패를 클라이언트에 보낸 후
  - 클라이언트가 채팅방 생성 API를 요청 후 다시 메시지 생성 API를 보내도록 한다.
- 해결 방법2

  - 클라이언트가 메시지 생성 API를 보낸 후
  - 서버가 해당 로직을 판단한 후 기능 수행

- 해결 방법2를 선택한 이유와 문제점
  - 중간에 채팅방 생성 된다는 점..
  - 하지만 메시지 생성을 보장해준다는 점에서 api가 uri로서 동작할 수 있다는 것이었다.
  - 또, api를 분리하는 것은 좋은 방법일 수 있지만, 개발시 고려해야할 점이 많다는 것
  - 프론트 개발자가 로직을 신경써서 개발해야한다는 문제점을 해결하기 위함이었다.

</br>

## 2.7 지속 연결로 접속량을 절약

</br>

### HTTP는 기본적으로 비 연결성이다.

- 요청과 응답시에만 유지하고 연결을 종료한다.
- 한정된 서버 자원을 효율적으로 사용 가능하다.
  - 요청이 끝났는데도 계속해서 클라이언트와 서버가 유지한다면 해당 서버를 사용할 수 없다.
- 하지만 비연결성으로인해 TCP/IP의 handshake로 인한 RTT가 추가된다.

</br>

### 2.7.1 지속 연결

</br>

- HTTP 1.1과 일부 HTTP 1.0에서 TCP 연결 문제를 해결하기 위해 지속 연결이라는 방법을 고안하였다.
- 지속 연결의 특징은 어느 한쪽이 명시적으로 연결을 종료하지 않는 이상 TCP 연결을 계속 유지한다.

</br>

### 2.7.2 파이프라인화

</br>

- 지속 연결은 여러 리퀘스트를 보낼 수 있도록 파이프라인화를 가능하게 한다.
- 파이프라이닝의 가장 큰 특징은
  - 기존 리퀘스트에 대해 리스폰스를 받지 않고도 리퀘스트를 보낼 수 있다.

### HTTP 1.1에서 파이프라이닝의 문제점

> 리스폰스를 받지 않고도 리퀘스트를 보낼 수 있는 것으로 문제를 해결하긴 했지만  
> 어쨌든 앞선 리스폰스를 받아야 후의 리스폰스를 받을 수 있기때문에  
> Head of Line Blocking이 발생한다.

- HTTP 2.0에서는

  - 멀티플렉싱 기법을 통해 선행되는 리퀘스트에서 병목이 생길 경우에도 이후 요청에 대한 응답을 받을 수 있다.

- 요약
  - HTTP 1.1에서는 파이프라이닝을 사용해도 결국 순차적 응답으로 인한 HOLB 문제가 있다.
  - HTTP 2.0에서는 멀티플렉싱을 사용하여 순차적 응답으로 인한 HOLB 문제를 해결했다.

</br>

### 2.8 쿠키를 사용한 상태 관리

</br>

> HTTP의 무상태성에서 로그인 및 인증이 필요한 경우  
> 사용자 정보를 어떻게 처리할 것이냐하는 문제가 있다.  
> 이를 해결하는 방법은 쿠키, 세션, JWT가 있다.

- Cookie는 로컬 스토리지에 저장되어 있다
  - 서버에 부담이 줄지만 쿠키가 탈취 될 경우 보안에서 문제가 있다.
- Session은 서버에서 sessionId를 관리한다
  - 멀티서버에서 세션 값을 관리할 때 세션 컴포넌트를 따로 관리해야하는 문제점
  - 서버 메모리에 session id를 저장해야해서 메모리에서 불리
- JWT도 로컬 스토리지에 저장
  - 액세스 토큰을 짧게 하고 리프레시 토큰을 활용하여 토큰 탈취 방지

</br>
