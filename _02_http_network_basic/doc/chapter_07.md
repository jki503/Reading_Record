# 제 7장 웹을 안전하게 지켜주는 HTTPS

## 7.1 HTTP의 약점

</br>

### 7.1.1 평문이기 때문에 도청 가능

</br>

> HTTP를 사용한 리퀘스트나 리스폰스는 HTTP 자신을 암호화하는 기능은 없기 때문에  
> 통신 전체가 암호화 되지 않는다.  
> 즉 요청과 응답이 평문으로 통신 된다.

</br>

- TCP/IP는 도청 가능한 네트워크
  - 암호화 되어 있지 않은 통신에 약점이 있는 이유는 TCP/IP 구조의 통신 내용은 전부 도청 가능
  - 암호화 된 메시지 속의 의미는 간파할 수 없지만, 암호화 메시지 자체도 도청 가능
  - 같은 게그먼트 통신에서 패킷을 수집하여 해석..
  - 패킷 캡처(wireshark)나 스니퍼라는 툴을 사용해서 가능

> 따라서 암호화로부터 패킷이 탈취되는 것을 방지하는 기법을 사용해야한다.

</br>

- 통신 암호화
  - HTTP는 암호화 구조는 없지만 SSL이나 TLS라는 다른 프로토콜을 조합하여 HTTP의 통신을 암호활 수 있다.
  - SSL등을 사용해 안전한 통신로를 확립하고 나서 그 통신로를 사용해 HTTP를 HTTPS나 HTTP over SSL이라고 부른다.

</br>

- 콘텐츠 암호화
  - HTTP를 사용해서 운반하는 내용을 암호화 하는 것, 즉 HTTP 메시지에 포함되는 컨텐츠만 암호화 하는 것이다.
  - 이 경우 클라이언트에서 메시지를 암호화해서 출력하는 처리가 필요하다.
  - 클라이언트 <-> 서버가 컨텐츠의 암복호화 구조를 가지고 있어야 함으로 평소에 유저가 사용되는 브라우저와 웹 서버에서 사용 어려움

### 7.1.2 통신 상대를 확인하지 않기 때문에 위장 가능

</br>

> HTTP를 사용한 리퀘스트나 리스폰스에서는 통신 상대를 확인하지 않는다.  
> 리퀘스트를 보낸 서버가 정말로 URI에서 지정된 호스트인지 아닌지,  
> 리스폰스를 반환한 클라이언트가 정말로 리퀘스트를 출력한 클라이언트인지 아닌지 모른다.

</br>

- 누구나 리퀘스트를 할 수 있다.
  - 상대가 누구인지 확인하는 처리가 없기 때문에 누구든지 리퀘스트를 보낼 수 있다.
  - 또한 리퀘스트가 오면 상대가 누구든지 무언가의 리스폰스를 반환한다
  - 상대가 누구인지 확인하지 않는다.
    - 본래 위장한 웹서버일 수도 있다.
    - 리스폰스를 반환한 클라이언트가 의도한 클라이언트인지 모른다.
    - 통신하고 있는 상대가 액세스 권한이 없는 상대일 수도 있다.
    - 의미없는 리퀘스트라도 수신하게 됨으로 Dos, DDos 공격을 피할 수 없다.

</br>

- 상대를 확인하는 증명서
  - HTTP에서는 통신 상대를 확인할 수 없지만 SSL로 가능하게 할 수 있다.
  - SSL은 암호화 뿐만 아니라 상대를 확인하는 수단으로 증명서를 제공하고 있다.
  - 증명서는 CA가 발행하는 것임으로 서버나 클라이언트가 실재하는 사실 증명

</br>

### 7.1.3 완전성을 증명할 수 없기 때문에 변조 가능

</br>

> 완전성이란 정보의 정확성을 가리킨다.  
> 그것을 증명할 수 없다는 것은 정보가 정확한지 아닌지를 확인할 수 없음을 의미한다.

</br>

- 수신한 내용이 다를지도 모른다.
  - HTTP가 완전성을 증명할 수 없다는 뜻은 통신 중간에 변조되어도 모른다는 것이다.
  - A -> B의 요청이나 응답이 같을지 알 수 없다는 것
  - 이와 같이 공격자가 도중에 리퀘스트나 리스폰스를 탈취해 변조하는 공격을 Man-in-the-Middle 공격이라고 부른다.

</br>

- 변조를 방지하려면?
  - MD5나 SHA-1등의 해시 값을 확인하는 방법
  - 파일의 디지털 서명을 확인하는 방법
  - 하지만 이역시 완전한 방법은 아니다.
    - 해시도 솔직히 레인보우 테이블로 GPU로 브루트포스 찍으면 뚫린다..
  - 결론은 HTTPS
    </br>

## 7.2 HTTP + 암호화 + 인증 + 완전성 보호 = HTTPS

</br>

- HTTPS
  - HTTP에 암호화나 인증 등의 구조를 더한 것을 HTTPS라고 부른다
  - 증명서는 서버 혹은 클라이언트의 신원을 증명한다.

</br>

### 7.2.2 HTTPS는 SSL의 껍질을 덮어쓴 HTTP

</br>

> HTTP는 새로운 애플리케이션 계층의 프로토콜이 아니다.  
> HTTP 통신을 하는 소켓 부분을 SSL이나 TLS라는 프로토콜로 대체한다.
>
> 보통 HTTP는 TCP와 통신하지만 SSL을 사용하지만 SSL을 사용한 경우에는  
> HTTP와 SSL이 통신하고 그 후 SSL과 TCP가 통신한다.

</br>

### 7.2.3 상호간에 키를 교환하는 공개키 암호화 방식

</br>

> SSL에서는 공개키 암호화 방식이라 불리는 암호화 방식을 채용하고 있다.  
> 암호화나 복호화 알고리즘 키를 가지고 있지 않으면 평문을 복호화 할 수 없지만  
> 키를 가지고 있는 누구라도 암호를 풀 수 있다.

</br>

- 공통키 암호의 딜레마

> 암호화와 복호화에 하나의 키를 같이 사용하는 방식을 공통키 암호라고 부른다.
> 공통키 암호화 방식은 상대방에게 키를 넘겨주지 않으면 안된다.  
> 그러나 키를 같이 보낼 경우 키를 사용하는 의미가 사라지고  
> 키를 공격자에게 탈취될 경우 문제가 된다.

</br>

- 두 개의 키를 사용하는 공개키 암호화

> 공개키 암호에서는 서로 다른 두 개의 키 페이를 사용한다  
> 한쪽은 비밀키라 부르고 한쪽은 공개키라고 한다.
>
> 공개키 암호를 사용한 암호화는 암호를 보내는 상대의 공개키를 사용해 암호화  
> 그리고 정보를 받는 쪽은 자신의 비밀키로 복호화 하낟.  
> 이 방식은 복호화하는 비밀키를 통신으로 보내지 않아서 키를 탈취될 걱정을 하지 않아도 된다.

</br>

### 7.2.4 공개키가 정확한지 아닌지를 증명하는 증명서

- 공개키 암호의 문제점

> 공개키가 진짜인지 아닌지를 증명할 수 없다.  
> 예를 들면 어떤 서버와 공개키 암호를 사용해서 통신을 시작할때  
> 수신한 공개키가 본래 의도한 서버가 발행한 공개키인지를 밝혀낼 수 없다.
>
> 이렇게 키를 인증하기 위해서 CA가 발행하는 공개키 증명서를 사용한다.

</br>

- CA 인증 절차
  - 먼저 서버의 운영자가 인증 기관에 공개키를 제출
  - 인증 기관은 제출된 공개키에 대해 디지털 서명을 하고 서명이 끝난 공개키를 만든다
  - 그리고 공개키 인증서에 서명이 끝난 공개키를 담는다.
  - 서버는 이 인증 기관에 의해서 작성된 공개키 인증서를 클라이언트에 보내고, 공개키 암호화를 한다.
  - 증명서를 받은 클라이언트는 증명 기관의 공개키를 사용해서 서버의 공개키를 인증한 것인지 확인 할 수 있다.

</br>

### 7.2.5 안전한 통신을 하는 HTTPS 구조

</br>

- 클라이언트가 Client Hello 메시지를 송신하면서 SSL 통신을 시작, 메시지에는 클라이언트가 제공하는 SSL의 버전을 지정하고, 암호 ㅅ위트로 불리는 리스트(사용한느 암호화의 알고리즘이나 키 사이즈 등)등이 포함
- 서버가 SSL 통신이 가능한 경우에는 Server Hello 메시지로 응답한다. 클라이언트와 같이 SSL 버전과 암호 스위트를 포함한다. 서버의 암호 스위트 내용은 클라이언트에서 받은 암호 스위트 내용에서 선택된 것
- 서버가 Certificate 메시지를 송신한다. 메시지에는 공개키 증명서가 포함되어 잇다.
- 서버가 Server Hello Done 메시지를 송신하여 최초의 SSL 네고시에이션 부분이 끝났음을 통지한다.
- SSL의 최초 네고시에이션이 종료되면 클라이언트가 Client Key exchange 메시지로 응답한다. 메시지에는 통신을 암호화하는데 사용하는 Pre-Master secret이 포함되어 있다. 이 메시지는 3의 공개키 증명서에서 꺼낸 공개키로 암호화 되어 있다.
- 클라이언트는 Change Cipher Spec 메시지를 송신한다. 이 메시지는 이 메시지 이후 통신은 암호키를 사용해서 진행한다는 것을 나타낸다.
- 클라이언트는 Finished 메시지를 송신한다. 이 메시지는 접속 전체의 체크 값을 포함하고 있다. 네고시에이션이 성공했는지 어떤지는 서버가 이 메시지를 올바르게 복호화 할 수 있는지 아닌지가 결정 된다.
- 서버에서도 change Cipher Spec 메시지를 송신한다.
- 서버도 Finished 메시지를 송신한다.
- 서버와 클라이언트의 Finished 메시지 교환이 완료되면 SSL에 의해서 접속은 확립된다. 물론 통신은 SSL에 의해서 보호된다. 이제부터는 애플리케이션 계층의 프로토콜에 의해 통신한다. 즉 HTTP 리퀘스트를 송신한다.
- 애플리케이션 계층의 프로토콜에 의한 통신이다. 즉 HTTP 리스폰스를 송신한다.
- 마지막에 클라이언트가 접속을 끊고, close_notify 메시지를 송신한다. 이후 TCP도 접속을 끊을때 TCP FIN 메시지를 보내 TCP 통신도 종료한다.

</br>

- [개인적으로 예전에 정리한 것](https://github.com/jki503/KDT_CS-tech-interview_Study/blob/main/network/doc/https.md)
