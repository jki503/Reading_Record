# CHAPTER 07. 객체 분해

## 프로시저 추상화와 데이터 추상화

</br>

- 프로시저 추상화
  - 소프트웨어가 무엇을 해야하는 지를 추상화
  - `기능 분해, 알고리즘 분해`
- 데이터 추상화
  - 소프트웨어가 무엇을 알아야하는 지를 추상화
  - `데이터를 중심으로 타입으로 추상화, 추상 데이터 타입`
  - `데이터를 중심으로 프로시저를 추상화, 객체지향`

> 소프트웨어는 데이터를 이용하여 정보를 표현하고 프로시저를 이용해 데이터를 조작

</br>

> 시스템을 분해하는 방법을 결정하려면 먼저 프로시저 추상화를 중심으로 할 것인지  
> 데이터 추상화를 중심으로 할 것인지 결정

</br>

## 프로시저 추상화와 기능 분해

</br>

### 메인 함수로서의 시스템

</br>

> 기능은 오랜 시간 시스템을 분해하는 기준이 되었으며  
> 이 같은 시스템 분해 방식을 알고리즘 분해 또는 기능 분해(`프로시저 추상화`)라고 부른다.

</br>

> 프로시저는 반복적으로 실행되거나 `거의 유사하게 실행되는 작업들을 하나의 장소에 모아놓음`으로써  
> 로직을 재사용하고 `중복을 방지할 수 있는 추상화 방법`  
> 프로시저를 추상화라 부르는 이유는 내부 구현을 몰라도 인터페이스를 사용할 수 있기 때문

</br>

- TOP-DOWN-Approach

> 최상위 기능을 추상화 해둔 뒤  
> 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법  
> 상위기능이 더 추상적

</br>

### 급여 시스템

</br>

> 급여 = 기본급 - (기본급 \* 소득세율)  
> 최상위 프로시저 `직원의 급여를 계산한다.`

</br>

- 직원의 급여를 계산한다
  - 사용자로부터 소득세율을 입력받는다
  - 직원의 급여를 계산한다
  - 양식에 맞게 결과를 출력한다.

</br>

> 모든 문장이 정제 과정을 거쳐 하위 문장은 보다 더 구체적이어야 함
> 보다 더 저수준의 문장이 될 때까지 기능을 분해해야한다.

</br>

- 직원의 급여를 계산한다
  - 사용자로부터 소득세율을 입력받는다
    - "세율을 입력하세요: " 라는 문장을 화면에 출력
    - 키보드를 통해 세율을 입력받는다.
  - 직원의 급여를 계산한다
    - 전역 변수에 저장된 직원의 기본급 정보를 얻는다.
    - 급여를 계산한다.
  - 양식에 맞게 결과를 출력한다.
    - "이름: {직원명}, 급여: {계산된 금액}" 형식에 따라 출력 문자열을 생성한다.

</br>

```ruby
$employees = ["직원A", "직원B", "직원C"]
$basePays = [400, 300, 250]

def main(name)
  taxRate = getTaxRate()
  pay = calculatePayFor(name, taxRate)
  puts(describeResult(name, pay))
end

def getTaxRate()
  print("세율을 입력하세요: ")
  return gets().chomp().to_f()
end

def calculatePayFor(name, taxRate)
  index = $employees.index(name)
  basePay = $basePays[index]
  return basePay - (basePay * taxRate)
end

def describeResult(name, pay)
  return "이름 : #{name}, 급여 : #{pay}"
end
```

> 위에서 Top Down 방식으로 구현한 ruby

</br>

- Top Down 문제점

|                  Top Down                   |
| :-----------------------------------------: |
| ![Top down 문제점](../res/_07_top_down.png) |

</br>

- 시스템은 하나의 메인 함수로 구성돼 있지 않다.

> 모든 기능을 자식 노드를 가지는 하나의 메인 기능으로 정의?  
> 하나의 메인 기능이라는 개념보다는 모든 기능들은 규모라는 측면에서 상이하다할지라도,  
> 기능성의 측면에서는 동등하게 독립적이고 완결된 하나의 기능을 표현

</br>

- 기능 추가나 변경으로 인해 메인함수를 빈번하게 수정할 경우?

> 위의 내용과 비슷한 말인데  
> 시스템은 여러개이 정상이 존재하지만 유일한 메인으로 설정할 경우  
> 새로운 기능을 추가할 때마다 매번 메인 함수를 수정해야한다... (TOP DOWN인데 변경은 양방향..)

```ruby
def sumOfBasePays()
  result = 0
  for basePay in $basePays
    result += basePay
  end
  puts(result)
end

```

</br>

> 모든 직원들의 기본급의 총합을 기능을 추가하는 요구사항이 접수 되었을 때  
> 메인 함수와는 성격이 맞지 않는 기능임으로 `어느 단계에 넣을지 애매하다.`

</br>

```ruby
def calculatePay(name)
  taxRate = getTaxRate()
  pay = calculatePayFor(name, taxRate)
  puts(describeResult(name, pay))
end
```

> 이런식으로 main 바로 하위 메서드로 정의한 후

</br>

```ruby
def main(operation, args={})
  case(operation)
  when :pay then calculatePay(args[:name])
  when :basePays then sumOfBasePays()
  end
end
```

</br>

> 이런식으로 Top Down 계층을 지키기 위해서  
> 잦은 main의 수정이 발생할 수 밖에 없다.  
> 기존 코드의 빈번한 수정은 버그 확률이 높아진인다!

</br>

- 비즈니스 로직이 사용자 인터페이스와 강하게 결합된다.

> 비즈니스 로직을 설계하는 초기 단계에 사용자 인터페이스의 관심사가 섞인다.  
> 이 경우의 문제는 비즈니스 로직과 사용자 인터페이스가 변경되는 빈도가 다르다.  
> 사용자 인터페이스가 시스템 내에서 가장 많이 변경되는 부분인데  
> 비즈니스 로직은 변경이 적게되는 영역  
> `따라서 두 로직이 섞여있는 하향식 접근법이 변경에 불안정한 아키텍처`

</br>

- 하향식 분해는 `너무 이른 시기에 함수들의 실행 순서를 고정시키기 때문에 유연성과 재사용성이 저하`

> main을 기준으로 더 작게 나누는 과정은  
> 설계를 시작하는 시점에 무엇을 해야하는 목적이 아닌  
> 어떻게 동작해야하는지에 대해 집중하게 한다.
>
> 즉, 구현을 염두에 두기 때문에 자연스레 함수들의 실행 순서를 정의하는 시간 제약을 강조...

</br>

- 데이터 형식이 변경 경우 파급효과를 예측할 수 없다.

</br>

> 어떤 함수가 어떤 데이터를 사용하고 있는지 추적하기 어렵다.  
> 즉 데이터의 변경이 어떤 버그를 야기하는지 찾기 어렵다.

```ruby
$employees = ["직원A", "직원B", "직원C", "아르바이트D", "아르바이트E", "아르바이트F"]
$basePays = [400, 300, 250, 1, 1, 1.5]
$hourlys = [false, false, false, true, true, true]
$timeCards = [0, 0, 0, 120, 120, 120]
```

> 아르바이트 직원의 이름과 시급은 정규 직원의 이름과 기본급을 보관하던 전역변수 `employees`와 `basePays`에 저장  
> 각 인덱스에 위치한 정보가 정규직원의 것인지, 아르바이트직원의 것인지 여부를 나타내는 변수 `hourlys`  
> timecards는 업무 누적시간, 정규직원의 경우 0

</br>

- 데이터가 마구잡이로 추가되고 변경된느 것이 하위 함수에 어떤 영향을 미치는지 파악하기 어렵다는 것..

</br>

> 급여시스템의 문제점은  
> 하나의 main 기능을 토대로 실행 순서를 모두 정해놓고 작성했다는 것이다.  
> 메인 기능 및 다른 상위기능이 변경된다고 할 때  
> 하위 기능의 변경을 야기 시켜 `변경에는 취약한 설계`

</br>

### 언제 하향식 분해가 유용?

</br>

> 설계가 어느 정도 안정화 된 후, 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이하지만  
> 설계를 용이하게 하는 것과 좋은 구조를 설계하는 방법이 동일한 것은 아니다.  
> 하향식은 이미 완전히 이해된 사실을 서술하기에 적합한 것이지,  
> 새로운 것을 개발하고 설계하고 발견하는 데에 적합한 것이 아니다...
